# Example Use Cases

Orbs VM is designed to enhance the capabilities of existing smart contracts. Here are some real world examples of how dapps are using this infrastructure. Notice that many of these examples could have been implemented with a centralized backend operated by the dapp itself, but this would create a centralized bottleneck that can be avoided by using the dozens of validators of Orbs Network.

Most of these examples can also be implemented using [Orbs Lambda](broken-reference) assuming the implementation meets its limitations (like relying on JavaScript only). Orbs Lambda is simpler to work with but less flexible. Any use-case that can be implemented by Orbs Lambda can also be implemented by Orbs VM. Orbs Lambda itself is actually implemented using Orbs VM.

* **Price feed similar to Chainlink or any other data oracle**\
  An Orbs VM container is free to fetch any data available online and is not limited to current on-chain state. External market price feed is a useful example of such data that can be read from a multitude of exchanges and price providers (Coinbase, Binance, CoinMarketCap, Coingecko, etc). The container continuously queries the price from all external sources, then signs the price off-chain and sends the signatures to a new dapp smart contract that verifies the Orbs quorum and records an aggregated price on-chain.\

* **Mobile push notifications for dapp end-users for on-chain events**\
  A dapp like Aave or Compound may want to alert its users when an on-chain condition is triggered - for example before their positions are in danger of being liquidated. An Orbs VM container monitors every block and checks if any of the positions passes a liquidation threshold and if so, triggers a mobile push notifications webhook, a tweet or a Telegram/Discord chat message. A more advanced version of this container will also generate an on-chain transaction to reduce the position in the protocol automatically to avoid liquidation completely by adjusting it according to the live market price.\

* **Calculating a staked vote according to historic balance snapshot on multiple chains**\
  An Orbs VM container can access on-chain data. Unlike smart contracts, it is not limited to the state head and can also query historic balances. Unlike smart contracts, it is also not limited to the same blockchain and can query multiple blockchains like Ethereum, Polygon and BNB Chain. Governance votes in dapps usually rely on a historic balance snapshot to avoid vote manipulation by buying tokens after the vote was announced. Dapp users often exist on multiple blockchains since tokens are often bridged. If the vote passes, the container can generate an on-chain transaction - a great way to implement decentralized smart contract upgrades.\

* **Auto compounding of vaults like Harvest.finance or other advanced strategies**\
  Vaults are decentralized "hedge funds" that implement a DeFi investment strategy on-chain in a completely trustless manner using smart contracts. Efficient investment strategies often require automatic triggers that adjust the position in some way. One example is auto compounding - selling rewards back to the base assets and re-depositing them to increase the position principal. Another example is comparing two alternative positions and moving funds automatically according to the one with the best APR. The container checks for relevant triggers by monitoring every new block and generates the transaction to trigger the appropriate response on-chain when the position needs to be adjusted.\

* **Executing large trades in DeFi without price impact by implementing TWAP**\
  Trades executed on on-chain DEX/AMM protocols are atomic and take place immediately. When the trade is relatively large or relies on a low liquidity pair, this can result in significant loss due to price impact. An Orbs VM container can break the single trade into multiple smaller ones every several minutes, allowing enough time for arbitrageurs to correct the pair back to market price, thus reducing price impact. The container will generate the numerous transactions to carry the smaller trades and adjust price limits according to live market prices to avoid front running.
